using UnityEngine;
using System.Collections;
using System.Collections.Generic;


public class VehicleSpawnerForVeins : MonoBehaviour {

	public GameObject theNPCCar; 
	public Dictionary<string, GameObject> myObjectMap;
	public float M_PI = 3.1415f;
	public float moveSpeed = 1f;
	int lineCounter = 0;

	// Use this for initialization
	void Start () {
	
		myObjectMap = new Dictionary<string, GameObject>();

	}
	
	// Update is called once per frame
	void Update () {
	
		//Read out the position information generated by Veins
		try
		{
		string[] text = System.IO.File.ReadAllLines(@"C:\veinsSimConnectionToUnity\Veins\veins-4a2\veins-veins-4a2\examples\veins\test_cout.txt");
		Debug.Log (text);
		string[] stringArry = text[lineCounter].Split('|');
			lineCounter++;
		
	
			Vector3 newPosition = new Vector3(float.Parse(stringArry[1]),50,float.Parse(stringArry[2]));
		

			GameObject currentNPC = null;
			if( myObjectMap.TryGetValue(stringArry[0], out currentNPC)){


				//set rotation of car
				myRotate(currentNPC,stringArry[5]);
			

				//set position
				currentNPC.transform.position = newPosition;

				//move in direction
				currentNPC.transform.Translate(myObjectMap[stringArry[0]].transform.forward * float.Parse(stringArry[4]) * moveSpeed * Time.deltaTime);
				Debug.Log(stringArry[4]);
			}

			else{

				myObjectMap.Add(stringArry[0],Instantiate(theNPCCar));


				//set rotation of car
				myRotate(myObjectMap[stringArry[0]],stringArry[5]);

				//place car
				myObjectMap[stringArry[0]].transform.position = newPosition;

				//move in direction
				myObjectMap[stringArry[0]].transform.Translate(myObjectMap[stringArry[0]].transform.forward * float.Parse(stringArry[4]) * moveSpeed * Time.deltaTime);
				Debug.Log(stringArry[4]);
			}
				
			
		
			//theNPCCar.transform.position = newPosition;
		}
		catch (System.IO.IOException  ex){

			Debug.Log ("TextDatei wird gerade von Veins geschrieben");
		}
	}

	void myRotate(GameObject currentNPC, string radAngle){

		// convert to degrees
		float angle = float.Parse(radAngle) * 180 / M_PI;
		
		// rotate angle so 0 is south (in OMNeT++'s angle interpretation 0 is east)
		angle = angle + 90;
		
		// normalize angle to -180 <= angle < 180
		while (angle < -180) angle += 360;
		while (angle >= 180) angle -= 360;
		
		currentNPC.transform.rotation = Quaternion.Euler(0,angle,0);
	}
}
